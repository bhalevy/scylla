# Copyright 2024-present ScyllaDB
#
# SPDX-License-Identifier: AGPL-3.0-or-later

from util import new_materialized_view, new_test_table
import glob
import json
import os
import nodetool
import subprocess
import time

def test_tombstone_gc_with_materialized_views(scylla_only, cql, scylla_path, scylla_data_dir, test_keyspace):
    """
    Reproduce https://github.com/scylladb/scylladb/issues/20424
    """
    schema = "k int primary key, v int, w int"
    with new_test_table(cql, test_keyspace, schema) as table:
        # Create a materialized view with same partition key as the base, and using a static column in the base as a clustering key in the view
        with new_materialized_view(cql, table, '*', 'k, v', 'k is not null and v is not null', extra="with gc_grace_seconds = 0") as mv:
            with nodetool.no_autocompaction_context(cql, mv):
                # nodetool.setlogginglevel(cql, "compaction", "trace")
                # Insert initial data into the base table
                cql.execute(f"insert into {table} (k, v, w) values (1, 1, 1)")
                # Flush the memtable so the following update won't get compacted in the memtable
                nodetool.flush_keyspace(cql, test_keyspace)
                # Update the static column in the view, causing a view update
                # with a shadowable row tombstone for the old value and recent row_marker for the new value
                cql.execute(f"insert into {table} (k, v) values (1, 2)")
                # Flush all tables now.
                # Typically this is done implicitly by major compaction
                # In order to maximize tombstone garbage collection by flushing
                # memtables of all table, and by that also forcing new commitlog segment
                # with a higher min_gc_time, but we skip this part intentionally
                # in this test's major compaction, to make sure the memtable contains
                # cells with old timestamps, that previously inhibited tombstone_gc.
                nodetool.flush_all(cql)

                # let gc_grace_seconds pass
                time.sleep(1)
                # Insert new view update into the memtable.
                # It will generate a view update with a shadowable row tombstone for the previous value
                # and the value of a new row with the old cell timestamp - that inhibits the purging
                # of the shadowable tombstone in the sstable without the fix for #20424
                cql.execute(f"insert into {table} (k, v) values (1, 3)")
                # do not flush before major compaction
                nodetool.compact(cql, mv, flush_memtables=False)
                tag = str(int(time.time()))
                nodetool.take_snapshot(cql, table, tag, skip_flush=True)

                # Verify that major compaction purged the shadowable tombstone generated by the 2nd insert
                table_data_path = glob.glob(os.path.join(scylla_data_dir, test_keyspace, mv.split('.')[1] + '*'))[0]
                sstable_files = glob.glob(os.path.join(table_data_path, "snapshots", tag, "me-*-Data.db"))
                assert len(sstable_files) == 1
                res = json.loads(subprocess.check_output([scylla_path, "sstable", "dump-data", sstable_files[0]]).decode())
                assert not "shadowable_tombstone" in str(res), f"shadowable_tombstone found in {res}"
